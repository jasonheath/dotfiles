#---------------------------------------------------------------------
# https://brew.sh/
#---------------------------------------------------------------------
eval "$(/usr/local/bin/brew shellenv)"
if type brew &>/dev/null
then
  HOMEBREW_PREFIX="$(brew --prefix)"
  if [[ -r "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh" ]]
  then
    source "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh"
  else
    for COMPLETION in "${HOMEBREW_PREFIX}/etc/bash_completion.d/"*
    do
      [[ -r "${COMPLETION}" ]] && source "${COMPLETION}"
    done
  fi
fi

#---------------------------------------------------------------------
# https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh
# depends on hombrew
#---------------------------------------------------------------------
GIT_PS1_SHOWDIRTYSTATE=true
# unstaged (*) and staged (+) changes will be shown next to the branch name

GIT_PS1_SHOWSTASHSTATE=true
# If something is stashed, then a '$' will be shown next to the branch name.

GIT_PS1_SHOWUNTRACKEDFILES=true
# If there're untracked files, then a '%' will be shown next to the branch name.

GIT_PS1_SHOWUPSTREAM="auto verbose"
# see the difference between HEAD and its upstream. A "<" indicates you are
# behind, ">" indicates you are ahead, "<>" indicates you have diverged and "="
# indicates that there is no difference. Adding "verbose" shows number of
# commits ahead/behind (+/-) upstream

GIT_PS1_SHOWCONFLICTSTATE=yes
# The prompt will include "|CONFLICT" when there are unresolved conflicts

GIT_PS1_SHOWCOLORHINTS=true
# colored hint about the current dirty state

#PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
 PS1='[\u@\h | \t | \w$(__git_ps1 " | %s")]\n\$ '
#PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
 #PROMPT_COMMAND='__git_ps1 "[\u@\h | \w | \t] "\\\$ "'
#[jaheath@C02G2566MD6R | 13:18:28 | ~/Development/progress/jahtomate | (main|u=)]

export CDPATH="~/Development/progress/:~/Development/personal/"

# per hombrew bash-completion@2 caveats
[[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] && . "/usr/local/etc/profile.d/bash_completion.sh"

# export LANG=en_US.UTF-8
export LANG=C
export LC_ALL=C # I think this takes precedence over $LANG but specifying both

# User configuration
# export MANPATH="/usr/local/man:$MANPATH"

# Preferred editor for local and remote sessions
if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='vim'
else
  # TODO: change this to export mvim on macOS and gvim for Linux && Windows
  export EDITOR='vim'
fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# ssh
# export SSH_KEY_PATH="~/.ssh/rsa_id"

#---------------------------------------------------------------------
# aliases
#---------------------------------------------------------------------
alias rm='rm -i'
alias cp='cp -i'

alias  ls='ls   -FG'
alias   l='ls   -FG'
alias  l1='ls  -1FG'
alias  ll='ls   -FGhl'
alias  la='ls  -AFG'
alias lal='ls  -AFGhl'
alias la1='ls -1AFGh'

alias cea='chezmoi edit --apply'
#test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
alias chrome='open -a /Applications/Google\ Chrome.app'
alias firefox='open -a /Applications/Firefox.app'
alias safari='open -a /Applications/Safari.app'

#---------------------------------------------------------------------
# PATH management
#---------------------------------------------------------------------
# This path mgmt is focused on adding things to the PATH that I've wanted to
# install so here we build up a hierarchical ordering of paths and then we
# append any preexisting PATH value to that so that our preferred executables
# are found prior to things on the path before we intereceded
x="$HOME/bin"
x="${x}:/usr/local/bin:/usr/local/sbin" # homebrew (https://brew.sh/)
x="${x}:/Applications/MacVim.app/Contents/bin"
x="${x}:/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
if [[ -n $PATH ]]; then
  x="$x:$PATH"
fi
export PATH=$x
unset x


#---------------------------------------------------------------------
# AWS [https://aws.amazon.com/]
#---------------------------------------------------------------------


#---------------------------------------------------------------------
# direnv [https://direnv.net/]
#---------------------------------------------------------------------
eval "$(direnv hook bash)"


#---------------------------------------------------------------------
# go [https://go.dev/]
#---------------------------------------------------------------------
export GOPATH=$HOME/go
mkdir -p $GOPATH
export PATH=$PATH:$GOPATH/bin

#---------------------------------------------------------------------
# habitat 
#---------------------------------------------------------------------
#source $HOME/.shell/habitat.env


#---------------------------------------------------------------------
# kubernetes [https://kubernetes.io/]
#---------------------------------------------------------------------
if [[ -d "$HOME/.krew" ]]; then
  export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"
fi 


#---------------------------------------------------------------------
# nvm [https://nvm.sh]
#---------------------------------------------------------------------
#if [[ -d $HOME/.nvm ]]; then
#  export NVM_DIR="$HOME/.nvm"
#  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # loads nvm
#  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # nvm bash_completion
#fi


#---------------------------------------------------------------------
# ruby [https://www.ruby-lang.org/]
#---------------------------------------------------------------------
if [[ -d $HOME/.rbenv ]]; then
  # https://github.com/rbenv/ruby-build/wiki
  # For Ruby versions 2.xâ€“3.0:
  # export RUBY_CONFIGURE_OPTS="--with-openssl-dir=$(brew --prefix openssl@1.1)"
  # Ruby 3.1 and above requires OpenSSL 3:
  export RUBY_CONFIGURE_OPTS="--with-openssl-dir=$(brew --prefix openssl@3)"

  eval "$(rbenv init - zsh)"
  RUBY_MANPATH="$(rbenv prefix)/share/man"
  export MANPATH="$RUBY_MANPATH:$MANPATH"
fi


#---------------------------------------------------------------------
# rust [https://www.rust-lang.org/]
#---------------------------------------------------------------------
. "$HOME/.cargo/env"
export RA_LOG="error" # the logging level for rust analyzer
export RUST_BACKTRACE="0"
#export RUST_LOG="info,manager::file_watcher=trace"

